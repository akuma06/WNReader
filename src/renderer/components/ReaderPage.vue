<template>
  <div v-if="chapter !== null" class="reader">
    <div class="header" :class="{ show: showHeader, hide: !showHeader }" ref="readerHeader" @mouseover="handleOverHeader" @mouseout="enableFade = true">
      <router-link :to="{ name: 'novel-page', params: { novel: novel.id.toString(), website: websiteModel.website.slug }}">
        <img src="@/assets/logo.png" />
      </router-link>
      <h1>{{ chapter.title }}</h1>
    </div>
    <div class="main" ref="readerContent" @scroll="handleScroll" @mousewheel="handleWheel">
      <div class="content">
        <h1 class="chapter-title" v-if="!this.loading">{{ chapter.title }}</h1>
        <div class="chapter-content" v-if="!this.loading" v-html="chapter.content" @click.prevent="handleContentClick"></div>
        <div class="chapter-content" v-if="this.loading">Loading...</div>
      </div>
      <div class="side">
        <ul>
          <li>
            <a href="#" @click.prevent="handlePanel(Panels.Comments)" title="Show comments">
              <font-awesome-icon icon="comment" />
            </a>
          </li>
          <li>
            <a href="#" @click.prevent="handlePanel(Panels.Chapters)" title="Chapter list">
              <font-awesome-icon icon="list" />
            </a>
          </li>
          <li>
            <a href="#" @click.prevent="handleFullscreen()" title="Fullscreen">
              <font-awesome-icon icon="external-link-alt" />
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="panel comments" ref="comments" :class="{ show: showPanel === Panels.Comments }">
      <comment-vue v-for="(comment, i) in comments" :key="'comm' + i" :comment="comment" />
    </div>
    <div class="panel chapterlist" ref="chapterlist" :class="{ show: showPanel === Panels.Chapters }">
      <a
        href="#"
        v-for="(c, i) in chapters"
        :key="'chapter_' + i"
        :class="{ selected: c.id === chapter.id }"
        @click.prevent="handleChapterItem(c)">
        <span>{{ c.title }}</span>
      </a>
    </div>
  </div>
</template>

<script lang="ts">
import Vue from 'vue'
import { Chapter, Novel, db, Comment } from '../lib/Database'
import Website from '../lib/Website'
import websites from '../lib/websites'
import CommentVue from './ReaderPage/Comment.vue'

enum Panels {
  None = 1,
  Comments,
  Chapters,
}

type ReaderPageData = {
  chapter: Chapter | null
  chapters: Chapter[]
  novel: Novel | null
  websiteModel: Website | null
  comments: Comment[]
  showPanel: Panels
  enableFade: boolean
  showHeader: boolean
  loading: boolean
  Panels: typeof Panels
}

let timeoutAnim: NodeJS.Timer | null = null
let timeoutFade: NodeJS.Timer | null = null

export default Vue.extend({
  name: 'ReaderPage',
  components: {
    CommentVue
  },
  data (): ReaderPageData {
    const websiteLoader = websites[this.$route.params.website]
    return {
      chapter: null,
      chapters: [],
      novel: null,
      websiteModel: (websiteLoader !== undefined) ? new Website({ website: websiteLoader }) : null,
      comments: [],
      showPanel: Panels.None,
      enableFade: true,
      showHeader: true,
      loading: true,
      Panels: Panels
    }
  },
  methods: {
    handleChapterItem (c: Chapter) {
      if (this.websiteModel !== null && c.id !== undefined) {
        this.loading = true
        this.websiteModel.loadChapter(c.novel, c.id)
          .then(chapterResponse => {
            this.chapter = chapterResponse.chapter
            db.novels.update(c.novel, { lastRead: this.chapter })
            this.checkPosition()
            this.loading = false
          })
      }
    },
    nextChapter () {
      if (this.websiteModel !== null && this.chapter !== null && this.chapter.next !== '') {
        this.loading = true
        this.websiteModel.nextChapter(this.chapter)
          .then(chapterResponse => {
            this.chapter = chapterResponse.chapter
            this.checkPosition()
            this.loading = false
          })
      }
    },
    prevChapter () {
      if (this.websiteModel !== null && this.chapter !== null && this.chapter.prev !== '') {
        this.loading = true
        this.websiteModel.prevChapter(this.chapter)
          .then(chapterResponse => {
            this.chapter = chapterResponse.chapter
            this.checkPosition()
            this.loading = false
          })
      }
    },
    handleKeyDown (e: KeyboardEvent) {
      if (this.websiteModel !== null && this.chapter !== null) {
        switch (e.which) {
          case 38:
            if (!this.loading && this.chapter.prev !== '') {
              this.hidedown(e)
            }
            break
          case 40:
            if (!this.loading && this.chapter.next !== '') {
              this.hideup(e)
            }
            break
        }
      }
    },
    handleKeyUp (e: KeyboardEvent) {
      if (this.websiteModel !== null && this.chapter !== null) {
        switch (e.which) {
          case 39:
            this.nextChapter()
            break
          case 37:
            this.prevChapter()
            break
          case 13:
            this.handleFullscreen(true)
            break
          case 27:
            this.handleFullscreen(false)
            break
          case 38:
            this.hidedown(e, true)
            break
          case 40:
            this.hideup(e, true)
            break
        }
      }
    },
    handleContentClick () {
      if (this.showPanel !== Panels.None) {
        this.showPanel = Panels.None
      }
    },
    handleWheel (e: MouseWheelEvent) {
      if (this.loading || this.chapter === null) {
        return
      }
      if (timeoutAnim !== null) {
        clearTimeout(timeoutAnim)
      }
      if (e.wheelDelta > 0 && this.chapter.prev !== '') {
        this.hidedown()
        timeoutAnim = setTimeout(() => this.hidedown(undefined, true), 200)
      } else if (e.wheelDelta < 0 && this.chapter.next !== '') {
        this.hideup()
        timeoutAnim = setTimeout(() => this.hideup(undefined, true), 200)
      }
    },
    checkPosition () {
      const reader = this.$refs['readerContent'] as HTMLDivElement
      if (this.chapter !== null && this.chapter.lastPosition !== undefined && reader) {
        reader.scrollTop = this.chapter.lastPosition
      } else if (reader) {
        reader.scrollTop = 0
      }
    },
    handleScroll () {
      const reader = this.$refs['readerContent'] as HTMLDivElement
      if (this.chapter !== null && this.chapter.id && reader && this.novel && this.novel.id) {
        let lastPosition: number | undefined
        if (reader.scrollHeight <= (reader.scrollTop + 1.3 * reader.offsetHeight) || reader.scrollTop <= 0.3 * reader.offsetHeight) {
          lastPosition = undefined
        } else lastPosition = reader.scrollTop
        db.chapters.update(this.chapter.id, { lastPosition })
        db.novels.update(this.novel.id, { lastRead: this.chapter })
      }
    },
    handlePanel (panel: Panels) {
      if (this.showPanel === panel) {
        this.showPanel = Panels.None
      } else {
        this.showPanel = panel
        if (panel === Panels.Chapters) {
          const chapterListPanel = this.$refs['chapterlist'] as HTMLDivElement
          if (chapterListPanel) {
            const selected = chapterListPanel.querySelector('.selected') as HTMLAnchorElement
            if (selected) {
              setTimeout(() => selected.scrollIntoView({ block: 'nearest', inline: 'nearest' }), 300)
            }
          }
        }
      }
    },
    handleFullscreen (fs?: boolean) {
      if (fs === undefined) {
        this.$electron.remote.getCurrentWindow().setFullScreen(!this.$electron.remote.getCurrentWindow().isFullScreen())
      } else if (fs !== this.$electron.remote.getCurrentWindow().isFullScreen()) {
        this.$electron.remote.getCurrentWindow().setFullScreen(fs)
      }
      this.fadeInHeader()
    },
    handleOverHeader () {
      if (timeoutFade) {
        clearTimeout(timeoutFade)
      }
      this.enableFade = false
    },
    hideup (e?: UIEvent, reset?: boolean) {
      const reader = this.$refs['readerContent'] as HTMLDivElement
      if (reader) {
        let divContent = reader.querySelector('.content') as HTMLDivElement
        if (divContent) {
          if (reset) {
            divContent.style.position = null
            divContent.style.top = null
            return
          }
          if (reader.scrollHeight <= (reader.scrollTop + reader.offsetHeight + 1)) {
            if (e !== undefined) e.preventDefault()
            divContent.style.position = 'relative'
            var pos = (divContent.style.top && divContent.style.top.replace('px', '') !== '') ? parseFloat(divContent.style.top.replace('px', '')) : -1
            pos = (pos >= 0) ? -1 : pos
            if (-pos > reader.offsetHeight) {
              this.nextChapter()
            } else {
              pos -= -0.2 * pos
              divContent.style.top = pos + 'px'
            }
          }
        }
      }
    },
    hidedown (e?: UIEvent, reset?: boolean) {
      const reader = this.$refs['readerContent'] as HTMLDivElement
      if (reader) {
        let divContent = reader.querySelector('.content') as HTMLDivElement
        if (divContent) {
          if (reset) {
            divContent.style.position = null
            divContent.style.top = null
            return
          }
          if (reader.scrollTop === 0) {
            if (e !== undefined) e.preventDefault()
            divContent.style.position = 'relative'
            var pos = (divContent.style.top && divContent.style.top.replace('px', '') !== '') ? parseFloat(divContent.style.top.replace('px', '')) : 1
            pos = (pos <= 0) ? 1 : pos
            if (pos > reader.offsetHeight) {
              this.prevChapter()
            } else {
              pos += 0.2 * pos
              divContent.style.top = pos + 'px'
            }
          }
        }
      }
    },
    fadeInHeader () {
      const readerHeader = this.$refs['readerHeader'] as HTMLDivElement
      if (readerHeader) {
        if (timeoutFade) {
          clearTimeout(timeoutFade)
        }
        if (this.enableFade) {
          this.showHeader = true
          timeoutFade = setTimeout(() => {
            this.showHeader = false
          }, 4000)
        }
      }
    }
  },
  watch: {
    chapter (newChapter: Chapter | null, oldChapter: Chapter | null) {
      if (newChapter !== null && this.novel && this.websiteModel !== null) {
        this.websiteModel.loadComments(this.novel, newChapter).then(comments => {
          this.comments = comments
        })
      }
    }
  },
  created () {
    if (this.websiteModel !== null) {
      const { novel, chapter } = this.$route.params
      this.websiteModel.loadChapter(parseInt(novel), parseInt(chapter)).then(chapterResponse => {
        this.novel = chapterResponse.novel
        this.chapter = chapterResponse.chapter
        this.chapters = chapterResponse.chapters
        this.checkPosition()
        this.fadeInHeader()
        this.loading = false
        return chapterResponse
      })
      document.addEventListener('keyup', this.handleKeyUp)
      document.addEventListener('keydown', this.handleKeyDown)
      document.addEventListener('mousemove', this.fadeInHeader)
      document.addEventListener('touchstart', this.fadeInHeader)
    }
  }
})
</script>

<style lang="scss" scoped>
@keyframes slideRight {
  from {
    right: 20px;
    opacity: 0.6;
  }

  to {
    right: 40px;
    opacity: 1;
  }
}
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}
.reader {
  display: flex;
  flex-direction: column;
  height: 100%;
  .header {
    width: 100%;
    display: flex;
    flex-direction: row;
    padding: 5px;
    position: fixed;
    top: 0px;
    left: 0px;
    z-index: 4;
    background-color: white;
    color: black;
    font-family: 'Nunito Sans','SF Pro Text','SF Pro Icons',Roboto,'Helvetica Neue',Helvetica,Arial,sans-serif;
    transition: opacity 1s;
    &.show {
      opacity: 1;
      animation: fadeIn .2s ease;
    }
    &.hide {
      opacity: 0;
      animation: fadeOut .2s ease;
    }
    img {
      height: 25px;
      width: 25px;
      margin: 0 10px;
    }
    h1 {
      font-size: 18px;
      font-weight: bold;
      line-height: 25px;
      padding: 0;
      margin: 0;
    }
  }
  .main {
    height: 100%;
    overflow: auto;
    min-width: 740px;
    font-family: Merriweather, serif;
    font-weight: 400;
    overflow-wrap: break-word;
    text-align: justify;
    .content {
      width: 60%;
      min-width: 700px;
      max-width: 1200px;
      padding: 2.5em;
      margin: auto;
      background-color: white;
      .chapter-content {
        font-size: 24px;
      }
      h1.chapter-title {
        border-bottom: 1px solid black;
        padding-bottom: 0.5em;
        text-align: center;
        margin-bottom: 0.5em;
      }
    }
    .side {
      width: 40px;
      height: 100%;
      background-color: var(--blackbg);
      position: fixed;
      right: 0;
      top: 0;  
      display: flex;
      flex-direction: column;
      justify-content: center;
      z-index: 3;
      ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
        li {
          color: white;
          padding: 5px;
          border-bottom: 1px solid grey;
          border-top: 1px solid grey;
          transition: background-color .2s linear;
          cursor: pointer;
          svg {
            width: 100%;
            height: 100%;
          }
          &:hover {
            background-color: rgb(61, 61, 61)
          }
        }
      }
    }
  }
  .panel {
    display: none;
    position: fixed;
    top: 0px;
    right: 40px;
    z-index: 2;
    height: 100%;
    background-color: white;
    width: 250px;
    box-shadow: -1px 0px 6px black;
    overflow: auto;
    &.show {
      display: block;
      animation: slideRight .2s ease;
    }
    &.comments {
      .comment-item {
        margin: 1em;
        &:first-child {
          margin-top: 35px;
        }
      }
    }
    &.chapterlist {
      a {
        color: black;
        display: block;
        border-bottom: 1px solid black;
        text-overflow: ellipsis;
        line-height: 30px;
        height: 40px;
        overflow: hidden;
        white-space: nowrap;
        span {
          padding: 5px 2px;
          display: inline-block;
          text-overflow: ellipsis;
        }
        &.selected {
          font-weight: bold;
          background-color: var(--biolet);
          color: white;
        }
      }
    }
  }
}
</style>
